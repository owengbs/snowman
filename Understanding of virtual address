我在linux宿主机上做了一下测试:

进程1用malloc动态分配了内存空间，并打印该返回地址，然后开始睡眠
进程2根据进程1的打印信息，向进程1动态分配的空间写数据

结果:进程2写操作失败，提示segmentation fault

思考:
其实操作系统为每一个进程维护了一个独立的可用虚拟地址空间，也即可用
!页表范围!(/*FIXME*/)，每一个进程都不允许访问不属于自己的虚拟地址，
malloc函数实际上为进程分配了新的页，并且更新了其可用页表范围，因而
其接下来对该页的访问时合法的，而其他进程则不允许访问该页内容，因为
其进程控制块中的可用页表范围不包括此地址。
所以总体说操作系统应该只有一个全局的页表用于对整个虚拟地址到物理地址
做映射，而每个进程则只允许访问一部分页表，至于哪些是合法的则维护在该
进程的PCB中.

由于整个地址空间非常庞大(如32位地址为4GB空间)，若一个页为4KB则需要1MB
个页表项(用32-12位去索引页表)，这个空间需求非常庞大.一种常用的解决办法
是用哈希映射的方式，把索引位(32-12位)经hash函数求得哈希值去索引哈希表，
若不同页映射到同一个哈希值则用链表链接(分离链接法).